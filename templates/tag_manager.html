<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tag Manager - local-booru</title>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <div class="tag-manager-container">
        <h1>Tag Manager</h1>
        <a href="/" class="back action-button">Back to Home</a>

        <div class="tag-manager-controls">
            <div class="autocomplete-container">
                <input type="text" id="filter-input" placeholder="Filter tags by name..." autocomplete="off">
            </div>
            <div class="sort-buttons">
                <span>Sort by:</span>
                <button id="sort-by-name" class="action-button active">Name</button>
                <button id="sort-by-count" class="action-button">Count</button>
            </div>
            <div class="filter-options">
                <label>
                    <input type="checkbox" id="show-orphans-only"> Show only orphans (0 images)
                </label>
            </div>
        </div>

        <h2>All Tags (<span id="visible-tag-count">0</span>)</h2>
        <div id="loading-message">Loading tags...</div>
        <ul id="tagList" class="tag-list"></ul>
    </div>

	<script src="/static/js/autocomplete.js"></script>
	<script src="/static/js/notifications.js"></script>
	<script>
	document.addEventListener('DOMContentLoaded', () => {
		// --- DOM Element References ---
		const tagListElem = document.getElementById('tagList');
		const loadingMessage = document.getElementById('loading-message');
		const filterInput = document.getElementById('filter-input');
		const sortByNameBtn = document.getElementById('sort-by-name');
		const sortByCountBtn = document.getElementById('sort-by-count');
		const showOrphansOnlyCheckbox = document.getElementById('show-orphans-only');
		const visibleTagCountSpan = document.getElementById('visible-tag-count');

		// --- State Management ---
		let allTags = [];
		let untaggedCount = 0;
		let currentSort = 'name'; // 'name' or 'count'

		// --- Core Functions ---

		/**
		 * Fetches the complete tag summary from the API and triggers the initial render.
		 */
		async function initialize() {
			loadingMessage.style.display = 'block';
			tagListElem.innerHTML = '';
			try {
				const response = await fetch('/api/tags/summary');
				if (!response.ok) throw new Error('Network response was not ok.');
				
				const data = await response.json();
				allTags = data.tags; 
				untaggedCount = data.untagged_count;
				applyFiltersAndRender();
			} catch (err) {
				console.error('Error fetching tags:', err);
				tagListElem.innerHTML = '<li style="text-align: center; color: #f44336;">Error loading tags. Please refresh the page.</li>';
			} finally {
				loadingMessage.style.display = 'none';
			}
		}

		/**
		 * Applies the current filter and sort settings to the master tag list
		 * and calls the render function.
		 */
		function applyFiltersAndRender() {
			let tagsToRender = [...allTags];
			const filterText = filterInput.value.trim().toLowerCase();

			if (filterText) {
				tagsToRender = tagsToRender.filter(tag => tag.name.toLowerCase().includes(filterText));
			}
			if (showOrphansOnlyCheckbox.checked) {
				tagsToRender = tagsToRender.filter(tag => tag.count === 0);
			}

			if (currentSort === 'name') {
				tagsToRender.sort((a, b) => a.name.localeCompare(b.name));
			} else { // currentSort === 'count'
				tagsToRender.sort((a, b) => b.count - a.count || a.name.localeCompare(b.name)); // Secondary sort by name
			}
			
			visibleTagCountSpan.textContent = tagsToRender.length;
			renderTagList(tagsToRender);
		}

		/**
		 * Renders a list of tag objects into the DOM.
		 * @param {Array<Object>} tags - The array of tag objects to render.
		 */
		function renderTagList(tags) {
			tagListElem.innerHTML = '';
			
			const shouldShowUntagged = untaggedCount > 0 && !filterInput.value && !showOrphansOnlyCheckbox.checked;
			if (shouldShowUntagged) {
				const untaggedLi = document.createElement('li');
				untaggedLi.className = 'tag-item';
				untaggedLi.innerHTML = `
					<div class="tag-display">
						<div>
							<a href="/gallery?q=untagged" class="tag-name-link">untagged</a>
							<span class="tag-count">(${untaggedCount})</span>
						</div>
					</div>
				`;
				tagListElem.appendChild(untaggedLi);
			}

			if (tags.length === 0 && !shouldShowUntagged) {
				tagListElem.innerHTML = '<li class="tag-item" style="text-align: center;">No tags match the current filters.</li>';
			}

			tags.forEach(tag => {
				const li = document.createElement('li');
				li.className = 'tag-item';
				li.id = `tag-item-${tag.id}`;

				li.innerHTML = `
					<div class="tag-display">
						<div>
							<a href="/gallery?q=${encodeURIComponent(tag.name)}" class="tag-name-link">${tag.name}</a>
							<span class="tag-count">(${tag.count})</span>
						</div>
						<div class="tag-controls">
							<button class="edit-btn action-button" data-tag-id="${tag.id}">Edit</button>
							<button class="force-delete-btn action-button" data-tag-id="${tag.id}" data-tag-name="${tag.name}">Force Delete</button>
						</div>
					</div>
					<div class="edit-form hidden" id="edit-form-${tag.id}">
						
						<!-- Group 1: Rename Action -->
						<div class="edit-action-group">
							<input type="text" value="${tag.name}" id="rename-input-${tag.id}" placeholder="New name...">
							<button class="rename-btn action-button" data-tag-id="${tag.id}">Rename</button>
						</div>

						<span>or</span>

						<!-- Group 2: Merge Action -->
						<div class="edit-action-group merge-group">
							<span>merge into:</span>
							<div class="autocomplete-container merge-autocomplete">
								 <input type="text" id="merge-input-${tag.id}" placeholder="Type a tag name..." autocomplete="off" data-tag-id-to-keep="">
								 <div id="suggestions-merge-${tag.id}" class="suggestions"></div>
							</div>
							<button class="merge-btn action-button" data-tag-id="${tag.id}" data-tag-name="${tag.name}">Merge</button>
						</div>

						<button class="cancel-btn action-button" data-tag-id="${tag.id}">Cancel</button>
					</div>
				`;
				tagListElem.appendChild(li);
			});
		}
		
		// --- UI Interaction ---

		/**
		 * Toggles the visibility of a tag's edit form and initializes autocomplete if needed.
		 * @param {string} tagId - The ID of the tag whose form should be toggled.
		 */
		function toggleEditForm(tagId) {
			const form = document.getElementById(`edit-form-${tagId}`);
			if (!form) return;
			
			const isNowHidden = form.classList.toggle('hidden');
			
			if (!isNowHidden) {
				const mergeInput = document.getElementById(`merge-input-${tagId}`);
				const suggestionsBox = document.getElementById(`suggestions-merge-${tagId}`);
				setupTagAutocomplete(mergeInput, suggestionsBox, (selectedTag) => {
					const tagObject = allTags.find(t => t.name === selectedTag);
					if (tagObject) {
						mergeInput.value = selectedTag;
						mergeInput.dataset.tagIdToKeep = tagObject.id;
					}
				});
				// Focus the first input in the form
				form.querySelector('input[type="text"]').focus();
			}
		}

		// --- API & State Update Handlers ---

		/**
		 * Handles the user's request to rename a tag.
		 * @param {string} tagId - The ID of the tag to rename.
		 */
		async function handleRename(tagId) {
			const newName = document.getElementById(`rename-input-${tagId}`).value.trim();
			if (!newName) {
				showToast('New tag name cannot be empty.', 'info');
				return;
			}

			const confirmed = await showConfirmation(`Are you sure you want to rename this tag to "${newName}"?`);
			if (!confirmed) return;

			try {
				const response = await fetch(`/api/tags/rename/${tagId}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ new_name: newName })
				});
				const result = await response.json();
				if (!response.ok) throw new Error(result.detail);

				showToast(result.message, 'success');
				const tagToUpdate = allTags.find(t => t.id == tagId);
				if (tagToUpdate) tagToUpdate.name = newName;
				
				applyFiltersAndRender();
				toggleEditForm(tagId); // Close the form on success
			} catch (err) {
				showToast(`Rename failed: ${err.message}`, 'error');
				toggleEditForm(tagId); // Also close the form on failure
			}
		}

		/**
		 * Handles the user's request to merge two tags.
		 * @param {string} tagIdToDelete - The ID of the tag that will be merged and deleted.
		 * @param {string} tagNameToDelete - The name of the tag to be deleted.
		 */
		async function handleMerge(tagIdToDelete, tagNameToDelete) {
			const mergeInput = document.getElementById(`merge-input-${tagIdToDelete}`);
			const tagIdToKeep = mergeInput.dataset.tagIdToKeep;

			if (!tagIdToKeep) {
				showToast('Please select a tag to merge into from the suggestions.', 'info');
				return;
			}
			
			const tagToKeepName = mergeInput.value;
			const confirmed = await showConfirmation(`Merge "${tagNameToDelete}" into "${tagToKeepName}"? This will delete "${tagNameToDelete}".`);
			if (!confirmed) return;

			const formData = new FormData();
			formData.append('tag_id_to_keep', tagIdToKeep);
			formData.append('tag_id_to_delete', tagIdToDelete);

			try {
				const response = await fetch('/api/tags/merge', { method: 'POST', body: formData });
				const result = await response.json();
				if (!response.ok) throw new Error(result.detail);
				
				showToast(result.message, 'success');
				const tagToDelete = allTags.find(t => t.id == tagIdToDelete);
				const tagToKeep = allTags.find(t => t.id == tagIdToKeep);
				if (tagToDelete && tagToKeep) {
					tagToKeep.count += tagToDelete.count; // Correctly update the count
				}
				allTags = allTags.filter(t => t.id != tagIdToDelete); // Remove the old tag

				applyFiltersAndRender();
			} catch (err) {
				showToast(`Merge failed: ${err.message}`, 'error');
				toggleEditForm(tagIdToDelete); // Close form on failure
			}
		}
		
		/**
		 * Handles the user's request to permanently delete a tag.
		 * @param {string} tagId - The ID of the tag to delete.
		 * @param {string} tagName - The name of the tag to delete.
		 */
		async function handleForceDelete(tagId, tagName) {
			const confirmed = await showConfirmation(`PERMANENTLY DELETE the tag "${tagName}"? This cannot be undone.`);
			if (!confirmed) return;

			try {
				const response = await fetch(`/api/tags/force_delete/${tagId}`, { method: 'POST' });
				const result = await response.json();
				if (!response.ok) throw new Error(result.detail);

				showToast(result.message, 'success');
				allTags = allTags.filter(t => t.id != tagId);
				applyFiltersAndRender();
			} catch (err) {
				showToast(`Deletion failed: ${err.message}`, 'error');
			}
		}

		// --- Event Listeners Setup ---

		filterInput.addEventListener('input', applyFiltersAndRender);
		showOrphansOnlyCheckbox.addEventListener('change', applyFiltersAndRender);

		sortByNameBtn.addEventListener('click', () => {
			currentSort = 'name';
			sortByNameBtn.classList.add('active');
			sortByCountBtn.classList.remove('active');
			applyFiltersAndRender();
		});

		sortByCountBtn.addEventListener('click', () => {
			currentSort = 'count';
			sortByCountBtn.classList.add('active');
			sortByNameBtn.classList.remove('active');
			applyFiltersAndRender();
		});
		
		tagListElem.addEventListener('click', (e) => {
			const target = e.target;
			const tagId = target.dataset.tagId;

			if (!tagId) return;

			if (target.matches('.edit-btn') || target.matches('.cancel-btn')) {
				e.preventDefault();
				toggleEditForm(tagId);
			} else if (target.matches('.rename-btn')) {
				handleRename(tagId);
			} else if (target.matches('.merge-btn')) {
				handleMerge(tagId, target.dataset.tagName);
			} else if (target.matches('.force-delete-btn')) {
				handleForceDelete(tagId, target.dataset.tagName);
			}
		});

		// --- Initial Load ---
		initialize();
	});
	</script>
</body>
</html>