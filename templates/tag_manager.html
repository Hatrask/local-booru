<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tag Manager - local-booru</title>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <div class="tag-manager-container">
        <h1>Tag Manager</h1>
        <a href="/" class="back action-button">Back to Home</a>

        <div class="tag-manager-controls">
            <div class="autocomplete-container">
                <input type="text" id="filter-input" placeholder="Filter tags by name..." autocomplete="off">
            </div>
            <div class="sort-buttons">
                <span>Sort by:</span>
                <button id="sort-by-name" class="action-button active">Name</button>
                <button id="sort-by-count" class="action-button">Count</button>
            </div>
            <div class="filter-options">
                <label>
                    <input type="checkbox" id="show-orphans-only"> Show only orphans (0 images)
                </label>
            </div>
        </div>

        <h2>All Tags (<span id="visible-tag-count">0</span>)</h2>
        <div id="loading-message">Loading tags...</div>
        <ul id="tagList" class="tag-list"></ul>
    </div>

	<script src="/static/js/autocomplete.js"></script>
	<script src="/static/js/notifications.js"></script>
	<script>
	document.addEventListener('DOMContentLoaded', () => {

		// --- 1. DOM ELEMENT REFERENCES ---
		const tagListElem = document.getElementById('tagList');
		const loadingMessage = document.getElementById('loading-message');
		const filterInput = document.getElementById('filter-input');
		const sortByNameBtn = document.getElementById('sort-by-name');
		const sortByCountBtn = document.getElementById('sort-by-count');
		const showOrphansOnlyCheckbox = document.getElementById('show-orphans-only');
		const visibleTagCountSpan = document.getElementById('visible-tag-count');

		// --- 2. STATE MANAGEMENT ---
		let allTags = [];
		let untaggedCount = 0;
		let currentSort = 'name'; // 'name' or 'count'

		// --- 3. CORE FUNCTIONS (Filtering, Sorting, Rendering) ---

		/**
		 * Fetches the complete tag summary from the API, populates state,
		 * and triggers the initial render.
		 */
		async function fetchAndInitialize() {
			loadingMessage.style.display = 'block';
			tagListElem.innerHTML = '';
			try {
				const response = await fetch('/api/tags/summary');
				if (!response.ok) throw new Error('Network response was not ok.');
				
				const data = await response.json();
				allTags = data.tags; 
				untaggedCount = data.untagged_count;
				applyFiltersAndRender();
			} catch (err) {
				console.error('Error fetching tags:', err);
				tagListElem.innerHTML = '<li class="tag-item" style="text-align: center; color: var(--color-danger);">Error loading tags. Please refresh the page.</li>';
			} finally {
				loadingMessage.style.display = 'none';
			}
		}

		/**
		 * The central function that applies the current filter and sort settings
		 * to the master tag list and calls the render function.
		 */
		function applyFiltersAndRender() {
			let tagsToRender = [...allTags];
			const filterText = filterInput.value.trim().toLowerCase();

			if (filterText) {
				tagsToRender = tagsToRender.filter(tag => tag.name.toLowerCase().includes(filterText));
			}
			if (showOrphansOnlyCheckbox.checked) {
				tagsToRender = tagsToRender.filter(tag => tag.count === 0);
			}

			if (currentSort === 'name') {
				// New: Sort by category first, then name
				tagsToRender.sort((a, b) => a.category.localeCompare(b.category) || a.name.localeCompare(b.name));
			} else { // currentSort === 'count'
				tagsToRender.sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
			}
			
			visibleTagCountSpan.textContent = tagsToRender.length;
			renderTagList(tagsToRender);
		}

		/**
		 * Renders a list of tag objects into the DOM.
		 * @param {Array<Object>} tags - The filtered and sorted array of tag objects to render.
		 */
		function renderTagList(tags) {
			tagListElem.innerHTML = '';
			
			// Conditionally display the special "untagged" item if there are no active filters.
			const shouldShowUntagged = untaggedCount > 0 && !filterInput.value && !showOrphansOnlyCheckbox.checked;
			if (shouldShowUntagged) {
				const untaggedLi = document.createElement('li');
				untaggedLi.className = 'tag-item';
				untaggedLi.innerHTML = `
					<div class="tag-display">
						<div>
							<a href="/gallery?q=untagged" class="tag-name-link">untagged</a>
							<span class="tag-count">(${untaggedCount})</span>
						</div>
					</div>
				`;
				tagListElem.appendChild(untaggedLi);
			}

			if (tags.length === 0 && !shouldShowUntagged) {
				tagListElem.innerHTML = '<li class="tag-item" style="text-align: center;">No tags match the current filters.</li>';
			}

			tags.forEach(tag => {
				const li = document.createElement('li');
				li.className = 'tag-item';
				li.id = `tag-item-${tag.id}`;
                const categoryClass = getTagCategoryClass(tag.category);
                const fullTagName = tag.category === 'general' ? tag.name : `${tag.category}:${tag.name}`;
                
				li.innerHTML = `
					<div class="tag-display">
						<div>
                            <span class="tag-pill ${categoryClass}" style="cursor: default; margin-right: 0.5rem;">${tag.category}</span>
							<a href="/gallery?q=${encodeURIComponent(fullTagName)}" class="tag-name-link">${tag.name}</a>
							<span class="tag-count">(${tag.count})</span>
						</div>
						<div class="tag-controls">
							<button class="edit-btn action-button" data-tag-id="${tag.id}">Edit</button>
							<button class="force-delete-btn action-button" data-tag-id="${tag.id}" data-tag-name="${tag.name}">Force Delete</button>
						</div>
					</div>
					<div class="edit-form hidden" id="edit-form-${tag.id}">
						<div class="edit-action-group">
							<input type="text" value="${tag.name}" id="rename-input-${tag.id}" placeholder="New name...">
							<button class="rename-btn action-button" data-tag-id="${tag.id}">Rename</button>
						</div>
                        <div class="edit-action-group">
							<span>Change category to:</span>
							<select id="category-select-${tag.id}">
                                ${VALID_CATEGORIES.map(c => `<option value="${c}" ${c === tag.category ? 'selected' : ''}>${c}</option>`).join('')}
                            </select>
							<button class="change-category-btn action-button" data-tag-id="${tag.id}" data-tag-name="${tag.name}">Save Category</button>
						</div>
						<span>or</span>
						<div class="edit-action-group merge-group">
							<span>merge into:</span>
							<div class="autocomplete-container merge-autocomplete">
								 <input type="text" id="merge-input-${tag.id}" placeholder="Type a tag name..." autocomplete="off" data-tag-id-to-keep="">
								 <div id="suggestions-merge-${tag.id}" class="suggestions"></div>
							</div>
							<button class="merge-btn action-button" data-tag-id="${tag.id}" data-tag-name="${tag.name}" data-tag-category="${tag.category}">Merge</button>
						</div>
						<button class="cancel-btn action-button" data-tag-id="${tag.id}">Cancel</button>
					</div>
				`;
				tagListElem.appendChild(li);
			});
		}
		
		/**
		 * Toggles the visibility of a tag's edit form and initializes its autocomplete component.
		 * @param {string} tagId - The ID of the tag whose form should be toggled.
		 */
		function toggleEditForm(tagId) {
			const form = document.getElementById(`edit-form-${tagId}`);
			if (!form) return;
			
			const isNowHidden = form.classList.toggle('hidden');
			
			if (!isNowHidden) {
				const mergeInput = document.getElementById(`merge-input-${tagId}`);
				const suggestionsBox = document.getElementById(`suggestions-merge-${tagId}`);
				// This setup provides a custom `onSelect` callback to populate the hidden data attribute.
				setupTagAutocomplete(mergeInput, suggestionsBox, { onSelect: (selectedTag) => {
                    const parsed = parseTag(selectedTag);
					const tagObject = allTags.find(t => t.name === parsed.name && t.category === parsed.category);
					if (tagObject) {
						mergeInput.value = selectedTag;
						mergeInput.dataset.tagIdToKeep = tagObject.id;
					}
				}});
				form.querySelector('input[type="text"]').focus();
			}
		}

		// --- 4. API HANDLERS ---

		/**
		 * Handles the API call to rename a tag.
		 * @param {string} tagId - The ID of the tag to rename.
		 */
		async function handleRename(tagId) {
			const newName = document.getElementById(`rename-input-${tagId}`).value.trim();
			if (!newName) {
				showToast('New tag name cannot be empty.', 'info');
				return;
			}
			const confirmed = await showConfirmation(`Are you sure you want to rename this tag to "${newName}"?`);
			if (!confirmed) return;

			try {
				const response = await fetch(`/api/tags/rename/${tagId}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ new_name: newName })
				});
				const result = await response.json();
				if (!response.ok) throw new Error(result.detail);

				showToast(result.message, 'success');
                await fetchAndInitialize(); // Full refresh
			} catch (err) {
				showToast(`Rename failed: ${err.message}`, 'error');
			} finally {
                toggleEditForm(tagId); // Always close the form after an attempt.
            }
		}

        /**
         * New: Handles the API call to change a tag's category.
         * @param {string} tagId - The ID of the tag to change.
         * @param {string} tagName - The name of the tag (for confirmation dialog).
         */
        async function handleChangeCategory(tagId, tagName) {
            const newCategory = document.getElementById(`category-select-${tagId}`).value;
            const confirmed = await showConfirmation(`Change category of "${tagName}" to "${newCategory}"?`);
            if (!confirmed) return;

            try {
                const response = await fetch(`/api/tags/change_category/${tagId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_category: newCategory })
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.detail);
                showToast(result.message, 'success');
                await fetchAndInitialize();
            } catch (err) {
                showToast(`Category change failed: ${err.message}`, 'error');
            } finally {
                toggleEditForm(tagId);
            }
        }

		/**
		 * Handles the API call to merge two tags.
		 * @param {string} tagIdToDelete - The ID of the tag that will be merged and deleted.
		 * @param {string} tagNameToDelete - The name of the tag to be deleted (for confirmation dialog).
         * @param {string} tagCategory - The category of the tag to be deleted.
		 */
		async function handleMerge(tagIdToDelete, tagNameToDelete, tagCategory) {
			const mergeInput = document.getElementById(`merge-input-${tagIdToDelete}`);
			const tagIdToKeep = mergeInput.dataset.tagIdToKeep;

			if (!tagIdToKeep) {
				showToast('Please select a tag to merge into from the suggestions.', 'info');
				return;
			}
			
			const tagToKeepName = mergeInput.value;
			const confirmed = await showConfirmation(`Merge "${tagNameToDelete}" into "${tagToKeepName}"? This will delete "${tagNameToDelete}".`);
			if (!confirmed) return;

			const formData = new FormData();
			formData.append('tag_id_to_keep', tagIdToKeep);
			formData.append('tag_id_to_delete', tagIdToDelete);

			try {
				const response = await fetch('/api/tags/merge', { method: 'POST', body: formData });
				const result = await response.json();
				if (!response.ok) throw new Error(result.detail);
				
				showToast(result.message, 'success');
                await fetchAndInitialize();
			} catch (err) {
				showToast(`Merge failed: ${err.message}`, 'error');
			} finally {
                toggleEditForm(tagIdToDelete);
            }
		}
		
		/**
		 * Handles the API call to permanently delete a tag from the database.
		 * @param {string} tagId - The ID of the tag to delete.
		 * @param {string} tagName - The name of the tag to delete (for confirmation dialog).
		 */
		async function handleForceDelete(tagId, tagName) {
			const confirmed = await showConfirmation(`PERMANENTLY DELETE the tag "${tagName}"? This cannot be undone.`);
			if (!confirmed) return;

			try {
				const response = await fetch(`/api/tags/force_delete/${tagId}`, { method: 'POST' });
				const result = await response.json();
				if (!response.ok) throw new Error(result.detail);

				showToast(result.message, 'success');
                await fetchAndInitialize();
			} catch (err) {
				showToast(`Deletion failed: ${err.message}`, 'error');
			}
		}

		// --- 5. INITIALIZATION & EVENT LISTENERS ---

		/**
		 * Attaches all event listeners for the page.
		 */
		function initializeEventListeners() {
			// Listeners for the top filter/sort controls.
			filterInput.addEventListener('input', applyFiltersAndRender);
			showOrphansOnlyCheckbox.addEventListener('change', applyFiltersAndRender);

			sortByNameBtn.addEventListener('click', () => {
				currentSort = 'name';
				sortByNameBtn.classList.add('active');
				sortByCountBtn.classList.remove('active');
				applyFiltersAndRender();
			});

			sortByCountBtn.addEventListener('click', () => {
				currentSort = 'count';
				sortByCountBtn.classList.add('active');
				sortByNameBtn.classList.remove('active');
				applyFiltersAndRender();
			});
			
			// A single delegated event listener for all actions on the tag list.
			tagListElem.addEventListener('click', (e) => {
				const target = e.target;
				const tagId = target.dataset.tagId;

				if (!tagId) return;

                e.preventDefault(); // Prevent default link behavior for all actions
				if (target.matches('.edit-btn') || target.matches('.cancel-btn')) {
					toggleEditForm(tagId);
				} else if (target.matches('.rename-btn')) {
					handleRename(tagId);
				} else if (target.matches('.merge-btn')) {
					handleMerge(tagId, target.dataset.tagName, target.dataset.tagCategory);
				} else if (target.matches('.force-delete-btn')) {
					handleForceDelete(tagId, target.dataset.tagName);
				} else if (target.matches('.change-category-btn')) {
                    handleChangeCategory(tagId, target.dataset.tagName);
                }
			});
		}
		
		// --- 6. START THE APPLICATION ---
		initializeEventListeners();
		fetchAndInitialize();
	});
	</script>
</body>
</html>