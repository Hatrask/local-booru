<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Gallery - local-booru</title>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <h1>Gallery</h1>

    <form class="search-form" action="/gallery" method="get" autocomplete="off">
        <div class="autocomplete-container">
            <input
                type="text"
                id="tagInput"
                name="q"
                value="{{ query }}"
                placeholder="Search tags..."
                autocomplete="off"
            />
            <div class="suggestions"></div>
        </div>
        <button type="submit">Search</button>
    </form>

    <div class="search-actions">
        <a href="/" class="action-button">Back to Home</a>
        <a id="batchEditLink" class="action-button" href="/batch_actions?q={{ query }}">Batch Actions</a>
    </div>

    <div id="thumbnail-controls">
        <button data-size="250">Small</button>
        <button data-size="400">Medium</button>
        <button data-size="900">Large</button>
    </div>

    <div id="gallery-grid" class="gallery"></div>
    <div id="pagination" style="text-align: center; margin-top: 2rem;"></div>

    <div id="lightbox-modal">
        <span id="lightbox-close">×</span>
        <div id="lightbox-content" class="view-mode">
            <!-- Image container will be dynamically populated -->
            <div id="lightbox-image-container">
                 <img id="lightbox-image" src="" alt="Lightbox image">
                 <div class="lightbox-nav">
                    <button id="lightbox-prev" title="Previous (A)">❮</button>
                    <button id="lightbox-next" title="Next (D)">❯</button>
                </div>
            </div>
           
            <!-- Sidebar for info and editing -->
            <div id="lightbox-sidebar">
                <div id="lightbox-view-mode-content">
                    <h4 id="lightbox-image-id"></h4>
                    <div id="lightbox-tags-display" class="tag-pills-container"></div>
                    <div class="lightbox-actions">
                         <button id="lightbox-edit-btn" class="action-button">Edit Tags</button>
                         <button id="lightbox-delete-btn" class="action-button danger">Delete</button>
                    </div>
                </div>

                <div id="lightbox-edit-mode-content">
                    <h4>Edit Tags</h4>
                    <div id="lightbox-tag-editor-container">
                        <div id="lightbox-tag-editor-pills"></div>
                        <div class="autocomplete-container">
                             <input type="text" id="lightbox-tag-input" placeholder="Add a tag..." autocomplete="off">
                             <div class="suggestions" id="lightbox-suggestions"></div>
                        </div>
                    </div>
                    <div id="lightbox-tag-helper">
                        <!-- Tag helper content (Suggestions/Search tabs) will go here -->
                    </div>
                    <div class="lightbox-actions">
                        <button id="lightbox-save-btn" class="action-button">Save</button>
                        <button id="lightbox-cancel-btn" class="action-button">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
        <p id="lightbox-loading-indicator" style="display: none;">Loading...</p>
    </div>

    <div id="tag-tooltip" class="thumb-tooltip"></div>

<script src="/static/js/notifications.js"></script>
<script src="/static/js/autocomplete.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- 1. CONFIGURATION & CONSTANTS ---
    const IMAGES_PER_PAGE = 42;
    const DEFAULT_THUMB_SIZE = '250';
    const TOOLTIP_SHOW_DELAY = 100;
    const TOOLTIP_HIDE_DELAY = 50;
    const TOOLTIP_MODE_KEY = 'localBooru_tooltipModeEnabled';

    // --- 2. DOM ELEMENT REFERENCES ---
    const galleryGrid = document.getElementById('gallery-grid');
    const paginationDiv = document.getElementById('pagination');
    const batchEditLink = document.getElementById('batchEditLink');
    const thumbnailControls = document.getElementById('thumbnail-controls');
    const mainTagInput = document.getElementById('tagInput');
    const mainSuggestionsBox = document.querySelector('.suggestions');
    const tagTooltip = document.getElementById('tag-tooltip');
    
    // Lightbox elements
    const lightboxModal = document.getElementById('lightbox-modal');
    const lightboxContent = document.getElementById('lightbox-content');
    const lightboxImage = document.getElementById('lightbox-image');
    const lightboxClose = document.getElementById('lightbox-close');
    const lightboxPrev = document.getElementById('lightbox-prev');
    const lightboxNext = document.getElementById('lightbox-next');
    const lightboxLoadingIndicator = document.getElementById('lightbox-loading-indicator');
    
    // Lightbox state-specific elements
    const lightboxImageId = document.getElementById('lightbox-image-id');
    const lightboxTagsDisplay = document.getElementById('lightbox-tags-display');
    const lightboxEditBtn = document.getElementById('lightbox-edit-btn');
    const lightboxDeleteBtn = document.getElementById('lightbox-delete-btn');
    const lightboxSaveBtn = document.getElementById('lightbox-save-btn');
    const lightboxCancelBtn = document.getElementById('lightbox-cancel-btn');
    const lightboxTagInput = document.getElementById('lightbox-tag-input');
    const lightboxSuggestions = document.getElementById('lightbox-suggestions');
    const lightboxTagEditorPills = document.getElementById('lightbox-tag-editor-pills');


    // --- 3. STATE MANAGEMENT ---
    const urlParams = new URLSearchParams(window.location.search);
    const query = urlParams.get('q') || "";
    let currentPage = parseInt(urlParams.get('page')) || 1;
    let totalPages = 0;
    let currentImages = [];
    let currentImageIndex = -1;
    let hasMorePages = true;
    let isLoading = false;
    let showTooltipTimer, hideTooltipTimer;
    let isTooltipModeEnabled = localStorage.getItem(TOOLTIP_MODE_KEY) === 'true';
    let lightboxEditStateTags = new Set();

    // --- 4. CORE FUNCTIONS ---

    /**
     * Fetches image data from the API and orchestrates the rendering of the page.
     * @param {number} [pageToLoad=1] - The page number to fetch and display.
     */
    async function loadPage(pageToLoad = 1) {
        hideTooltip();
        if (isLoading) return;
        isLoading = true;
        
        galleryGrid.innerHTML = '<p>Loading images...</p>'; 
        currentImages = [];
        currentPage = pageToLoad;
        
        const newUrl = `/gallery?q=${encodeURIComponent(query)}&page=${currentPage}`;
        window.history.pushState({ page: currentPage, query: query }, '', newUrl);

        if (query) {
            addRecentSearch(query);
        }

        try {
            const response = await fetch(`/api/images?q=${encodeURIComponent(query)}&page=${currentPage}&limit=${IMAGES_PER_PAGE}`);
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            
            const data = await response.json();
            currentImages = data.images;
            totalPages = Math.ceil(data.total / IMAGES_PER_PAGE);
            hasMorePages = data.has_more;

            renderGallery(data.images);
            updatePaginationControls(data.total);

        } catch (err) {
            console.error("Failed to load images:", err);
            galleryGrid.innerHTML = '<p style="text-align: center; color: #ff6b6b;">Error loading images. Please try again.</p>';
        } finally {
            isLoading = false;
        }
    }

    /**
     * Generates the HTML for a set of color-coded, clickable tag pills.
     * @param {Array<Object>} tags - An array of tag objects [{name, category}].
     * @param {boolean} [isEditable=false] - If true, renders editable pills with remove buttons.
     * @returns {string} The HTML string for the tag pills.
     */
    function renderTagPills(tags, isEditable = false) {
        if (!tags || tags.length === 0) {
            return !isEditable ? '<span>No tags</span>' : '';
        }
        return tags.map(tag => {
            const categoryClass = getTagCategoryClass(tag.category);
            const rawTagName = tag.category === 'general' ? tag.name : `${tag.category}:${tag.name}`;
            if (isEditable) {
                 return `<span class="tag-pill ${categoryClass}" data-tag="${rawTagName}">${tag.name}<button class="remove-tag-btn">×</button></span>`;
            } else {
                const searchLink = `/gallery?q=${encodeURIComponent(rawTagName)}`;
                return `<a href="${searchLink}" class="tag-pill ${categoryClass}">${tag.name}</a>`;
            }
        }).join('');
    }

    /**
     * Renders the grid of image thumbnails into the gallery container.
     * @param {Array<Object>} images - An array of image objects from the API.
     */
    function renderGallery(images) {
        galleryGrid.innerHTML = '';
        if (images.length === 0) {
            galleryGrid.innerHTML = '<p style="text-align: center;">No images found.</p>';
            return;
        }

        images.forEach((img, index) => {
            const thumb = document.createElement('div');
            thumb.className = 'thumb';
            thumb.dataset.index = index;
            thumb.innerHTML = `<img src="/media/images/${img.filename}" alt="Image ${img.id}" loading="lazy">`;
            thumb.addEventListener('click', () => openLightbox(index));
            galleryGrid.appendChild(thumb);
        });
    }
    
    /**
     * Updates the pagination controls (page info and buttons).
     * @param {number} totalImages - Total number of images matching the query.
     */
    function updatePaginationControls(totalImages) {
        paginationDiv.innerHTML = '';
        if (totalImages === 0) return;

        paginationDiv.innerHTML = `
            <p style="margin-bottom: 0.5rem;">Page ${currentPage} of ${totalPages} (${totalImages} images)</p>
            <button id="prev-page" ${currentPage <= 1 ? 'disabled' : ''}>← Previous</button>
            <button id="next-page" ${!hasMorePages ? 'disabled' : ''}>Next →</button>
        `;

        document.getElementById('prev-page').addEventListener('click', () => loadPage(currentPage - 1));
        document.getElementById('next-page').addEventListener('click', () => loadPage(currentPage + 1));
    }

    // --- 5. LIGHTBOX FUNCTIONS ---

    /**
     * Displays the lightbox modal for a specific image.
     * @param {number} index - The index of the image to show from the `currentImages` array.
     */
    function openLightbox(index) {
        hideTooltip();
        currentImageIndex = index;
        const image = currentImages[currentImageIndex];
        if (!image) return;

        showImageInLightbox(image);
        setLightboxMode('view');
        lightboxModal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }

    /**
     * Hides the lightbox modal.
     */
    function closeLightbox() {
        lightboxModal.style.display = 'none';
        document.body.style.overflow = 'auto';
    }
    
    function setLightboxMode(mode) { // 'view' or 'edit'
        if (mode === 'edit') {
            lightboxContent.classList.remove('view-mode');
            lightboxContent.classList.add('edit-mode');
            renderTagEditor();
        } else {
            lightboxContent.classList.remove('edit-mode');
            lightboxContent.classList.add('view-mode');
        }
    }

    /**
     * Loads the image and its metadata into the lightbox view.
     * @param {Object} image - The image object to display.
     */
    function showImageInLightbox(image) {
        if (!image) return;
        lightboxImage.src = `/media/images/${image.filename}`;
        lightboxImage.alt = `Image ID: ${image.id}`;
        
        // --- View Mode Setup ---
        lightboxImageId.textContent = `Image ID: ${image.id}`;
        lightboxTagsDisplay.innerHTML = renderTagPills(image.tags, false);
        
        // --- Button data attributes ---
        lightboxDeleteBtn.dataset.imageId = image.id;
        lightboxSaveBtn.dataset.imageId = image.id;
    }
    
    function renderTagEditor() {
        const image = currentImages[currentImageIndex];
        if (!image) return;

        lightboxEditStateTags.clear();
        image.tags.forEach(tag => {
            const rawTagName = tag.category === 'general' ? tag.name : `${tag.category}:${tag.name}`;
            lightboxEditStateTags.add(rawTagName);
        });
        
        updateEditorPills();
    }

    function updateEditorPills() {
        lightboxTagEditorPills.innerHTML = '';
        const sortedTags = Array.from(lightboxEditStateTags).sort();
        sortedTags.forEach(rawTagName => {
            let name, category;
            if (rawTagName.includes(':')) {
                [category, name] = rawTagName.split(':', 2);
            } else {
                category = 'general';
                name = rawTagName;
            }
            const categoryClass = getTagCategoryClass(category);
            const pill = document.createElement('span');
            pill.className = `tag-pill ${categoryClass}`;
            pill.dataset.tag = rawTagName;
            pill.innerHTML = `${name}<button class="remove-tag-btn">×</button>`;
            lightboxTagEditorPills.appendChild(pill);
        });
    }

    async function handleSaveTags() {
        const imageId = lightboxSaveBtn.dataset.imageId;
        if (!imageId) return;

        try {
            const response = await fetch(`/api/image/${imageId}/tags`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tags: Array.from(lightboxEditStateTags) })
            });

            if (!response.ok) {
                const result = await response.json();
                throw new Error(result.detail || 'Failed to save tags.');
            }
            
            const result = await response.json();
            currentImages[currentImageIndex].tags = result.tags;

            showToast('Tags saved successfully!', 'success');
            showImageInLightbox(currentImages[currentImageIndex]);
            setLightboxMode('view');

        } catch (error) {
            console.error('Error saving tags:', error);
            showToast(error.message, 'error');
        }
    }

    async function handleDelete(event) {
        const imageId = event.target.dataset.imageId;
        if (!imageId) return;
        const confirmed = await showConfirmation('Are you sure you want to permanently delete this image? This cannot be undone.');
        if (!confirmed) return;
        try {
            const response = await fetch(`/api/image/${imageId}`, { method: 'DELETE' });
            if (response.ok) {
                showToast('Image deleted successfully.', 'success');
                closeLightbox();
                loadPage(currentPage);
            } else {
                const result = await response.json();
                showToast(result.detail || 'Failed to delete image.', 'error');
            }
        } catch (error) {
            console.error('Error deleting image:', error);
            showToast('An unexpected error occurred.', 'error');
        }
    }
    
    /**
     * Handles navigation within the lightbox, including loading subsequent pages.
     * @param {number} direction - `1` for next, `-1` for previous.
     */
    async function navigateLightbox(direction) {
        const newIndex = currentImageIndex + direction;
        if (newIndex >= 0 && newIndex < currentImages.length) {
            openLightbox(newIndex); // Re-opens lightbox for the new image
            return;
        }
        if (newIndex >= currentImages.length && hasMorePages) {
            await loadNextPageInLightbox();
        } else if (newIndex < 0 && currentPage > 1) {
            await loadPrevPageInLightbox();
        }
    }

    /**
     * A helper function for lightbox navigation that loads the next page of images.
     */
    async function loadNextPageInLightbox() {
        if (isLoading) return;
        lightboxLoadingIndicator.style.display = 'block';
        await loadPage(currentPage + 1);
        lightboxLoadingIndicator.style.display = 'none';
        openLightbox(0);
    }

    /**
     * A helper function for lightbox navigation that loads the previous page of images.
     */
    async function loadPrevPageInLightbox() {
        if (isLoading) return;
        lightboxLoadingIndicator.style.display = 'block';
        await loadPage(currentPage - 1);
        lightboxLoadingIndicator.style.display = 'none';
        openLightbox(currentImages.length - 1);
    }

    // --- 6. MISC UI & TOOLTIP FUNCTIONS ---

    /**
     * Sets the CSS variable for thumbnail width and saves the preference to localStorage.
     * @param {string} size - The width in pixels (e.g., "250").
     */
    function applyThumbSize(size) {
        document.documentElement.style.setProperty('--thumb-width', `${size}px`);
        localStorage.setItem('thumbSize', size);
        thumbnailControls.querySelector('.active')?.classList.remove('active');
        thumbnailControls.querySelector(`[data-size="${size}"]`)?.classList.add('active');
    }

    /**
     * Hides the dynamic tooltip and clears any pending timers.
     */
    function hideTooltip() {
        clearTimeout(showTooltipTimer);
        clearTimeout(hideTooltipTimer);
        tagTooltip.classList.remove('visible');
    }

    /**
     * Calculates the optimal position for the tooltip and displays it.
     * @param {HTMLElement} thumb - The thumbnail element being hovered.
     * @param {MouseEvent} event - The mouse event that triggered the display.
     */
    function showTooltip(thumb, event) {
        const index = parseInt(thumb.dataset.index, 10);
        const image = currentImages[index];
        if (!image || !image.tags) return;

        tagTooltip.innerHTML = renderTagPills(image.tags, false);
        
        // Use a temporary class to calculate dimensions without a visual flicker.
        tagTooltip.classList.add('visible-calculating');
        const tooltipRect = tagTooltip.getBoundingClientRect();
        tagTooltip.classList.remove('visible-calculating');

        let left = event.clientX + 15;
        let top = event.clientY + 15;

        // Smartly adjust position to prevent overflowing the viewport.
        if (left + tooltipRect.width > window.innerWidth) {
            left = event.clientX - tooltipRect.width - 15;
        }
        if (top + tooltipRect.height > window.innerHeight) {
            top = event.clientY - tooltipRect.height - 15;
        }

        tagTooltip.style.left = `${left}px`;
        tagTooltip.style.top = `${top}px`;
        tagTooltip.classList.add('visible');
    }

    // --- 7. EVENT HANDLERS ---

    /**
     * Handles all global keydown events for navigation and feature toggles.
     * @param {KeyboardEvent} e - The keyboard event.
     */
    function handleKeydown(e) {
        // Ignore key presses if the user is typing in an input field.
        if (e.target.matches('input, textarea')) {
             if (e.key === 'Escape' && lightboxModal.style.display === 'flex') {
                closeLightbox();
            }
            return;
        }

        // Lightbox-specific shortcuts
        if (lightboxModal.style.display === 'flex') {
            if (lightboxContent.classList.contains('view-mode')) {
                 if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') navigateLightbox(1);
                 else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') navigateLightbox(-1);
            }
            if (e.key === 'Escape') closeLightbox();
        } else {
            // Gallery-specific shortcuts
            if ((e.key.toLowerCase() === 'd' || e.key === 'ArrowRight') && hasMorePages) {
                loadPage(currentPage + 1);
            } else if ((e.key.toLowerCase() === 'a' || e.key === 'ArrowLeft') && currentPage > 1) {
                loadPage(currentPage - 1);
            } else if (e.key.toLowerCase() === 't') {
                isTooltipModeEnabled = !isTooltipModeEnabled;
                localStorage.setItem(TOOLTIP_MODE_KEY, isTooltipModeEnabled);
                const message = `Tooltip mode ${isTooltipModeEnabled ? 'enabled' : 'disabled'}.`;
                showToast(message, 'info');
                if (!isTooltipModeEnabled) {
                    hideTooltip();
                }
            }
        }
    }

    /**
     * Sets up the event listeners for the dynamic tooltip.
     */
    function setupTooltipEvents() {
        galleryGrid.addEventListener('mouseover', e => {
            if (!isTooltipModeEnabled) return;
            const thumb = e.target.closest('.thumb');
            if (thumb) {
                clearTimeout(hideTooltipTimer);
                showTooltipTimer = setTimeout(() => showTooltip(thumb, e), TOOLTIP_SHOW_DELAY);
            }
        });

        galleryGrid.addEventListener('mouseout', e => {
            if (!isTooltipModeEnabled) return;
            const thumb = e.target.closest('.thumb');
            if (thumb) {
                clearTimeout(showTooltipTimer);
                hideTooltipTimer = setTimeout(hideTooltip, TOOLTIP_HIDE_DELAY);
            }
        });
        
        tagTooltip.addEventListener('mouseover', () => { if (!isTooltipModeEnabled) return; clearTimeout(hideTooltipTimer); });
        tagTooltip.addEventListener('mouseout', () => { if (!isTooltipModeEnabled) return; hideTooltipTimer = setTimeout(hideTooltip, TOOLTIP_HIDE_DELAY); });
    }
    
    /**
     * Sets up all initial event listeners for the page.
     */
    function initialize() {
        const savedSize = localStorage.getItem('thumbSize') || DEFAULT_THUMB_SIZE;
        applyThumbSize(savedSize);
        if (query) { batchEditLink.style.display = 'inline-block'; }

        // General event listeners
        lightboxClose.addEventListener('click', closeLightbox);
        lightboxPrev.addEventListener('click', () => navigateLightbox(-1));
        lightboxNext.addEventListener('click', () => navigateLightbox(1));
        document.addEventListener('keydown', handleKeydown);
        thumbnailControls.addEventListener('click', (e) => {
            if (e.target.dataset.size) { applyThumbSize(e.target.dataset.size); }
        });
        window.addEventListener('popstate', (e) => {
            const newPage = e.state?.page || 1;
            if (newPage !== currentPage) loadPage(newPage);
        });

        // Lightbox state change listeners
        lightboxEditBtn.addEventListener('click', () => setLightboxMode('edit'));
        lightboxCancelBtn.addEventListener('click', () => setLightboxMode('view'));
        lightboxSaveBtn.addEventListener('click', handleSaveTags);
        lightboxDeleteBtn.addEventListener('click', handleDelete);
        
        // Lightbox tag editor listeners
        lightboxTagEditorPills.addEventListener('click', (e) => {
            if (e.target.classList.contains('remove-tag-btn')) {
                const pill = e.target.closest('.tag-pill');
                if (pill) {
                    lightboxEditStateTags.delete(pill.dataset.tag);
                    updateEditorPills();
                }
            }
        });
        
        lightboxTagInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission
                const tagValue = e.target.value.trim().toLowerCase();
                if (tagValue) {
                    lightboxEditStateTags.add(tagValue);
                    updateEditorPills();
                    e.target.value = '';
                    // Hide suggestions manually if autocomplete is open
                    const suggestionsEl = e.target.nextElementSibling;
                    if (suggestionsEl && suggestionsEl.classList.contains('suggestions')) {
                        suggestionsEl.style.display = 'none';
                    }
                }
            }
        });

        // Setup autocomplete for the new tag input in the lightbox
        setupTagAutocomplete(lightboxTagInput, lightboxSuggestions, {
            onSelect: (tag) => {
                lightboxEditStateTags.add(tag);
                updateEditorPills();
                lightboxTagInput.value = '';
            }
        });

        // Setup main page components
        setupTooltipEvents();
        setupTagAutocomplete(mainTagInput, mainSuggestionsBox, { showSavedSearches: true });
        
        // Kick off the initial page load.
        loadPage(currentPage);
    }

    // START THE APPLICATION
    initialize();
});
</script>
</body>
</html>